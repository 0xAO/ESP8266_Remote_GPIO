#include "ets_sys.h"
#include "osapi.h"
#include "gpio.h"
#include "os_type.h"
#include "user_config.h"
#include "user_interface.h"

#undef __packed
#define __packed

enum {PACKET_TYPE_PUSHCMD,PACKET_TYPE_PUSH_RESP_UNIQ,PACKET_TYPE_EXEC_CMD,PACKET_TYPE_EXEC_CMD_RESP,PACKET_TYPE_TELL_YOUR_MAC_REQ,PACKET_TYPE_TELL_YOUR_MAC_RESP};

volatile bool cansend=true;
volatile int gpio_setter_clck=-1;
volatile int gpio_setter_port=0;

typedef struct {
        uint8_t magic[7]; //k4uwifi
        uint8_t magic_version;//0x00
        uint8_t command_id;
} hdr_t __packed;

typedef struct {
        hdr_t hdr;
        uint8_t cmd[64];
} cmd_push_t __packed;

typedef struct {
        hdr_t hdr;
        uint8_t cmd_uniq_ident[16];
        uint8_t req_salt[24];
} cmd_push_resp_t __packed;

typedef struct{
        hdr_t hdr;
        uint8_t cmd_uniq_ident[16];//generated by server
        uint8_t sha256[32];//cmd_text+cmd_uniq+cmd_salt
}cmd_exec_cmd_t __packed;

typedef struct{
        hdr_t hdr;
        uint8_t result_status;
        uint8_t result_status_text[32];
}cmd_exec_cmd_response_t __packed;

typedef struct {
        hdr_t hdr;
}cmd_tell_you_mac_req_t __packed;

typedef struct {
        hdr_t hdr;
}cmd_tell_you_mac_response_t __packed;


uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void)
{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
 
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 8;
            break;
 
        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;
            break;
 
        case FLASH_SIZE_16M_MAP_512_512:
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;
            break;
 
        case FLASH_SIZE_32M_MAP_512_512:
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;
            break;
 
        default:
            rf_cal_sec = 0;
            break;
    }
 
    return rf_cal_sec;
}


struct RxControl {
    signed rssi:8;
    unsigned rate:4;
    unsigned is_group:1;
    unsigned:1;
    unsigned sig_mode:2;
    unsigned legacy_length:12;
    unsigned damatch0:1;
    unsigned damatch1:1;
    unsigned bssidmatch0:1;
    unsigned bssidmatch1:1;
    unsigned MCS:7;
    unsigned CWB:1;
    unsigned HT_length:16;
    unsigned Smoothing:1;
    unsigned Not_Sounding:1;
    unsigned:1;
    unsigned Aggregation:1;
    unsigned STBC:2;
    unsigned FEC_CODING:1;
    unsigned SGI:1;
    unsigned rxend_state:8;
    unsigned ampdu_cnt:8;
    unsigned channel:4;
    unsigned:12;
};
 
struct LenSeq {
    uint16_t length;
    uint16_t seq;
    uint8_t  address3[6];
};

struct sniffer_buf {
    struct RxControl rx_ctrl;
    uint8_t buf[36];
    uint16_t cnt;
    struct LenSeq lenseq[1];
};

struct sniffer_buf2{
    struct RxControl rx_ctrl;
    uint8_t buf[112];
    uint16_t cnt;
    uint16_t len;
};


void printmac(char* buf, unsigned int o)
{
   os_printf("%02x:%02x:%02x:%02x:%02x:%02x\n", buf[o+0], buf[o+1], buf[o+2], buf[o+3], buf[o+4], buf[o+5]);
}

uint8_t my_mac[6];

const uint8_t k4u_mac[]={0xFF,0x00,0x00,'k','4','u'};

typedef struct {
        uint8_t version_type_subtype; //0x80
        uint8_t flags;//0x00
        uint8_t duration[2];//auto
        uint8_t dest_mac[6];//everythink k4u_mac
        uint8_t src_mac[6];
        uint8_t transmitter_mac[6];
        uint8_t frag_seq_num[2];
	uint8_t tkip_bytes[8];
}ieee80211_hdr_t __packed;

volatile int msec=0;

void send_packet(const uint8_t * dest_mac,const uint8_t* data_from,size_t data_len);

void fill_hdr(hdr_t* hdr,uint8_t cmd_id){
        memcpy(hdr->magic,"k4uwifi",7);
        hdr->magic_version=0x00;
        hdr->command_id=cmd_id;
}


cmd_push_t last_received_cmdpush;
cmd_push_resp_t last_sended_cmdpush_resp;

void generate_uniq_pushcmd_response(){
	fill_hdr((hdr_t*)&last_sended_cmdpush_resp,PACKET_TYPE_PUSH_RESP_UNIQ);
	os_get_random((unsigned char*)&last_sended_cmdpush_resp.cmd_uniq_ident[0],sizeof(last_sended_cmdpush_resp.cmd_uniq_ident));
        os_get_random((unsigned char*)&last_sended_cmdpush_resp.req_salt[0],sizeof(last_sended_cmdpush_resp.req_salt));
}

bool check_exec_sha256(uint8_t* sha){
	return true;
}

uint8_t exec_command(uint8_t* cmd,uint8_t* save_result_text_here){
	int v1;
	int v2;
	char cmd_copy[65];
	cmd_copy[64]=0;
	memcpy(&cmd_copy[0],cmd,64);
	if(memcmp(cmd_copy,"gpio_trigger",12)==0){
		cmd_copy[12]=0;
		cmd_copy[15]=0;
		cmd_copy[17]=0;
		v1=atoi(&cmd[13]);
		v2=atoi(&cmd[16]);
//		if(v1==12 || v1==13 || v1==14 || v1==16 || v1==15){
	        if(v1==13 || v1==14){
			if(gpio_setter_clck!=-1){
				os_sprintf(save_result_text_here,"gpio busy (%d)",gpio_setter_clck);
			}else{
				GPIO_OUTPUT_SET(v1,0);
				if(v2>50){v2=50;}
				gpio_setter_port=v1;
		        	gpio_setter_clck=v2;
				strcpy(save_result_text_here,"gpio_trigger executed");
			}
		}else{
			 os_sprintf(save_result_text_here,"gp bp %d/%d",v1,v2);
//			 strcpy(save_result_text_here,"gpio_trigger bad port");
		}
	}else{//gpio_trigger
		strcpy(save_result_text_here,"nothing to do");
	}
}


static void wifi_rx_cb(uint8_t *buf, uint16_t len)
{
    wifi_promiscuous_enable(0);
    struct RxControl * rx_ctl_info=(struct RxControl*)buf;
    uint8_t * received_data_buf=buf+sizeof(struct RxControl);
    ieee80211_hdr_t* ieee_hdr=(ieee80211_hdr_t*)received_data_buf;
    uint8_t * payload_buf=received_data_buf+sizeof(ieee80211_hdr_t);
    size_t payload_len=len-(sizeof(struct RxControl)+(sizeof(ieee80211_hdr_t)));

    if (len >= sizeof(struct RxControl)+(sizeof(ieee80211_hdr_t)+sizeof(hdr_t)) ){
	if(
		memcmp(&ieee_hdr->dest_mac[0],k4u_mac,6)==0 || //k4
		memcmp(&ieee_hdr->src_mac[0],k4u_mac,6)==0 || // src
		memcmp(&ieee_hdr->transmitter_mac[0],k4u_mac,6)==0 || //dest
		false //template
	){
		hdr_t* hdr=(hdr_t*)payload_buf;

                os_printf("detected len = %d payload len=%d pb[0-5]=%02x %02x %02x %02x %02x\n",len,payload_len,*payload_buf,payload_buf[1],payload_buf[2],payload_buf[3],payload_buf[4],payload_buf[5]);
   	        printmac(&ieee_hdr->transmitter_mac[0],0);
		if(memcmp(&hdr->magic[0],"k4uwifi",7)==0 && hdr->magic_version==0x00){
			if(hdr->command_id==PACKET_TYPE_TELL_YOUR_MAC_REQ && payload_len>=sizeof(cmd_tell_you_mac_req_t)){
				os_printf("PACKET_TYPE_TELL_YOUR_MAC_REQ REQUESTED\n");
				cmd_tell_you_mac_req_t* tell_mac_req=(cmd_tell_you_mac_req_t*)payload_buf;
				//making response with my IPee :)
				cmd_tell_you_mac_response_t tell_mac_resp;
				fill_hdr((hdr_t*)&tell_mac_resp,PACKET_TYPE_TELL_YOUR_MAC_RESP);
				send_packet(&ieee_hdr->src_mac[0],(const uint8_t*)&tell_mac_resp,sizeof(cmd_tell_you_mac_response_t));
			}else{
				//this packets can be only for me ( check dest ((transmitter)))
				if(memcmp(&ieee_hdr->transmitter_mac[0],my_mac,6)==0){
					os_printf("YES. this packet for me!");
					if(hdr->command_id==PACKET_TYPE_PUSHCMD && payload_len>=sizeof(cmd_push_t)){
						//save it to buffer.
						os_printf("PACKET_TYPE_PUSHCMD\n");
						memcpy((void*)&last_received_cmdpush,payload_buf,sizeof(cmd_push_t));
						generate_uniq_pushcmd_response();
                		                send_packet(&ieee_hdr->src_mac[0],(const uint8_t*)&last_sended_cmdpush_resp,sizeof(cmd_push_resp_t));
					}else if(hdr->command_id==PACKET_TYPE_EXEC_CMD && payload_len>=sizeof(cmd_exec_cmd_t)){
						os_printf("PACKET_TYPE_EXEC_CMD\n");
						cmd_exec_cmd_t * cmd_exec_cmd=(cmd_exec_cmd_t*)payload_buf;

						cmd_exec_cmd_response_t cmd_exec_cmd_response;
						fill_hdr((hdr_t*)&cmd_exec_cmd_response,PACKET_TYPE_EXEC_CMD_RESP);
						cmd_exec_cmd_response.result_status=0;

						if(memcmp(&last_sended_cmdpush_resp.cmd_uniq_ident[0],&cmd_exec_cmd->cmd_uniq_ident[0],sizeof(cmd_exec_cmd->cmd_uniq_ident))==0 ){
							os_printf("uniq right!...checking sha");
							if(check_exec_sha256(&cmd_exec_cmd->sha256[0])){
							    os_printf("sha right! executing\n");
							    last_received_cmdpush.cmd[sizeof(last_received_cmdpush.cmd)-1]=0;
							    cmd_exec_cmd_response.result_status=exec_command(&last_received_cmdpush.cmd[0],&cmd_exec_cmd_response.result_status_text[0]);
							}else{
								//bad sha
								strcpy(&cmd_exec_cmd_response.result_status_text[0],"bad signanture");
							}
						}else{
							//bad uniq
					///		os_sprintf(&cmd_exec_cmd_response.result_status_text[0],"RDBGZ: %02x <> %02x",last_sended_cmdpush_resp.cmd_uniq_ident[2],cmd_exec_cmd->cmd_uniq_ident[2]);
							strcpy(&cmd_exec_cmd_response.result_status_text[0],"bad request id");
						}

						send_packet(&ieee_hdr->src_mac[0],(const uint8_t*)&cmd_exec_cmd_response,sizeof(cmd_exec_cmd_response_t));
						generate_uniq_pushcmd_response();//always regenerate
					}
				}
			}
		}else{//magic ok
//			os_printf("bad hdr magic or version\n");
		}
	}//mac check
    }//len
wifi_promiscuous_enable(1);
}


char send_packet_buffer[2048];
void send_packet(const uint8_t * dest_mac,const uint8_t* data_from,size_t data_len){
	while(!cansend){}
	cansend=false;
	if(data_len>1500 && data_from){data_len=1500;}
	ieee80211_hdr_t* hdr=(ieee80211_hdr_t*)send_packet_buffer;
	hdr->version_type_subtype=0x08;//0x40; //0x80;
	hdr->flags=0x00;
	hdr->duration[0]=0;
	hdr->duration[1]=0;
	memcpy(&hdr->dest_mac,k4u_mac,6);
	memcpy(&hdr->src_mac,my_mac,6);
	memcpy(&hdr->transmitter_mac,dest_mac,6);
	hdr->frag_seq_num[0]=0;
	hdr->frag_seq_num[1]=0;
	if(data_len && data_from){
	//	os_printf("YES PRINTF!\n");
		memcpy(send_packet_buffer+sizeof(ieee80211_hdr_t),data_from,data_len);
	}
	int fr=wifi_send_pkt_freedom(send_packet_buffer,data_len+sizeof(ieee80211_hdr_t),false);
//	os_printf("send pck (queue) ret=%d\n",fr);
}

void freedom_result(uint8_t status){
	cansend=true;
//	os_printf("freedom_result = %d\n",status);
}




void timer_clck(void *arg)
{
    msec++;
    if(msec==100){msec=0;os_printf("every 10 sec timer mymac=");/* printmac(my_mac,0); send_packet("\xFF\x00\x00k4u","HELLO",5);*/}
    if(gpio_setter_clck==0){
	GPIO_OUTPUT_SET(gpio_setter_port,1);
	gpio_setter_clck=-1;
    }else if(gpio_setter_clck>-1){
	gpio_setter_clck--;
    }

}

void system_init_done(){
    wifi_promiscuous_enable(0);
    wifi_station_disconnect();

    wifi_get_macaddr(0x00,my_mac);

    generate_uniq_pushcmd_response();

    wifi_set_promiscuous_rx_cb(wifi_rx_cb);
    wifi_set_channel(1);
    wifi_promiscuous_enable(1);

    gpio_init();



//Set GPIO2 to output mode

PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U,FUNC_GPIO12);
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U,FUNC_GPIO13);
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U,FUNC_GPIO14);
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,FUNC_GPIO15);
//PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO2_U,FUNC_GPIO2);

PIN_PULLUP_EN(PERIPHS_IO_MUX_MTDI_U);
PIN_PULLUP_EN(PERIPHS_IO_MUX_MTCK_U);
PIN_PULLUP_EN(PERIPHS_IO_MUX_MTMS_U);
PIN_PULLUP_EN(PERIPHS_IO_MUX_MTDO_U);

//GPIO_OUTPUT_SET(12,1);
GPIO_OUTPUT_SET(13,1);
GPIO_OUTPUT_SET(14,1);

//GPIO_OUTPUT_SET(15,1);
//GPIO_OUTPUT_SET(2,0);


    int r=wifi_register_send_pkt_freedom_cb(freedom_result);
//	os_printf("wifi register cb = %d\n",r);
//    char command_dest_mac[6] = {0x00, 0x00, 0x00, 'k', '4', 'u'};
//    wifi_promiscuous_set_mac(my_mac);

}

os_timer_t m_timer;

user_init()
{
    uart_init(115200, 115200);
   // os_printf("\n\nSDK version:%s\n", system_get_sdk_version());
 


    system_set_os_print(1);
    wifi_set_opmode(STATION_MODE);  

    os_timer_disarm(&m_timer);
    os_timer_setfn(&m_timer, (os_timer_func_t *) timer_clck, NULL);
    os_timer_arm(&m_timer, 100, 1);


    system_init_done_cb(system_init_done);
}
