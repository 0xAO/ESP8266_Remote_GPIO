#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>

#include <unistd.h>

#include <netinet/in.h>

#include <net/if.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>

#include <sys/time.h>
#include <time.h>

#include <sys/ioctl.h>
#include <net/if.h>
#include <net/if_arp.h>

#include <endian.h>

#define __packed __attribute__((__packed__))
#define true (1==1)
#define false (1==0)

uint8_t my_mac[6]={0xFF,0x00,0x00,'k','4','u'};
uint8_t dest_mac[6]={0xFF,0x00,0x00,'k','4','u'};



#ifndef true
#define true (1==1)
#endif

#ifndef false
#define false (1!=1)
#endif

#ifndef bool
#define bool int
#endif

int openSocket( const char device[IFNAMSIZ] )
{
	struct ifreq ifr;
	struct sockaddr_ll ll;
	const int protocol = ETH_P_ALL;
	int sock = -1;

	assert( sizeof( ifr.ifr_name ) == IFNAMSIZ );

	sock = socket( PF_PACKET, SOCK_RAW, htons(protocol) );
	if ( sock < 0 )
	{
		perror( "socket failed (do you have root priviledges?)" );
		return -1;
	}

	memset( &ifr, 0, sizeof( ifr ) );
	strncpy( ifr.ifr_name, device, sizeof(ifr.ifr_name) );
	if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0)
	{
		perror("ioctl[SIOCGIFINDEX]");
		close(sock);
		return -1;
	}

	memset( &ll, 0, sizeof(ll) );
	ll.sll_family = AF_PACKET;
	ll.sll_ifindex = ifr.ifr_ifindex;
	ll.sll_protocol = htons(protocol);
	if ( bind( sock, (struct sockaddr *) &ll, sizeof(ll) ) < 0 ) {
		perror( "bind[AF_PACKET]" );
		close( sock );
		return -1;
	}

//	struct ifreq ifr;
	if (ioctl(sock,SIOCGIFHWADDR,&ifr)!=-1) {
		const unsigned char* mac=(unsigned char*)ifr.ifr_hwaddr.sa_data;
		memcpy(my_mac,mac,6);
		printf("mac: %02X:%02X:%02X:%02X:%02X:%02X\n",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
	}

	return sock;
}

uint8_t snd_packet[8192];
int snd_packet_pos=0;

void packet_reset(){
    snd_packet_pos=0;
}

void packet_append_hex(const char* d){
    char hex[3];
    hex[2]=0;
    while(*d){
        hex[0]=*d++;
        hex[1]=*d++;
        snd_packet[snd_packet_pos++]=strtol(hex,NULL,16);
    }
}

void packet_append_data(const char* d, int len){
    memcpy(&snd_packet[snd_packet_pos],d,len);
    snd_packet_pos+=len;
}


int packet_get_len(){
    return snd_packet_pos;
}

uint8_t* packet_get_data(){
    return snd_packet;
}

enum {PACKET_TYPE_PUSHCMD,PACKET_TYPE_PUSH_RESP_UNIQ,PACKET_TYPE_EXEC_CMD,PACKET_TYPE_EXEC_CMD_RESP,PACKET_TYPE_TELL_YOUR_MAC_REQ,PACKET_TYPE_TELL_YOUR_MAC_RESP}; //tell you mac - allowing k4u src/dest

typedef struct {
	uint8_t magic[7]; //k4uwifi
	uint8_t magic_version;//0x00
	uint8_t command_id;
} hdr_t __packed;

typedef struct {
	hdr_t hdr;
	uint8_t cmd[64];
} cmd_push_t __packed;

typedef struct {
	hdr_t hdr;
	uint8_t cmd_uniq_ident[16];
	uint8_t req_salt[24];
} cmd_push_resp_t __packed;

typedef struct{
	hdr_t hdr;
	uint8_t cmd_uniq_ident[16];//generated by server
	uint8_t sha256[32];//cmd_text+cmd_uniq+cmd_salt
}cmd_exec_cmd_t __packed;

typedef struct{
	hdr_t hdr;
	uint8_t result_status;
	uint8_t result_status_text[32];
}cmd_exec_cmd_response_t __packed;

typedef struct {
	hdr_t hdr;
}cmd_tell_you_mac_req_t __packed;

typedef struct {
	hdr_t hdr;
}cmd_tell_you_mac_response_t __packed; //see from src


typedef struct {
	uint8_t ver;
	uint8_t pad;
	uint16_t len;
	uint32_t preset;
	uint8_t flags;
	uint16_t rx_flags;
	uint8_t rate;
	uint16_t channel;
}my_rtap_t __packed;


const uint8_t k4u_mac[]={0xFF,0x00,0x00,'k','4','u'};

void create_packet_and_send_data(int sock,const uint8_t* data,size_t len){
       packet_reset();
	//usleep(250000);//250 ms pause
	//radiotap
	//succ var
	/*
        packet_append_hex("00");//ver 
        packet_append_hex("00"); //pad
        packet_append_hex("2400");//len
        packet_append_hex("2F4000FF");//present flags
        packet_append_hex("FFFFA020080000000000006B4FFFFFFFDC370100000010026C09FFFF"); //hdr 36 bytes
	*/
	my_rtap_t my_rtap={0};
	my_rtap.ver=0x00;
	my_rtap.pad=0x00;
	my_rtap.len=htole16(sizeof(my_rtap_t));
	my_rtap.preset=htole32((1<<1) | (1<<15)|(1<<2)|(1<<3));//flags rx rate channel
	my_rtap.rx_flags=0x0008|0x0010;//dont wait ack and use custom seq
	my_rtap.rate=0x02;//1mbit
	my_rtap.channel=htole16(2412);//channel 1
	my_rtap.flags=0x14;

	for(int i=0;i<sizeof(my_rtap);i++){
		printf("%02x",*(((uint8_t*)&my_rtap)+i));
	}printf("\n");

	printf("rtap h=%d szof=%d\n",my_rtap.len,sizeof(my_rtap));


	packet_append_data((uint8_t*)&my_rtap,sizeof(my_rtap));
//      packet_append_hex("08");//verison=0, type 0x02 - data, subtype - 0x00 - data

        packet_append_hex("80");//0x08 beacon
        uint8_t flags=(1<<6)|(0x00);//from ds to ds. (ad hoc). protected. (can use 0x02 - from ds to sta via ap)
        packet_append_data(&flags,1);
        packet_append_hex("0000"); //time duration (auto fill)

        packet_append_data(k4u_mac,6);//dest
        packet_append_data(my_mac,6);//source
        packet_append_data(dest_mac,6);//source

        int frag_seq=rand()&0xFFF0;
        packet_append_data((const char*)&frag_seq,2); //seq and frag
        packet_append_hex("1636716000000000");//tkip params
        packet_append_data(data,len);
        packet_append_hex("00000000");//crc (autocalc);
        int wl=write(sock,packet_get_data(),packet_get_len());
        printf("wl=%d\n",wl);

}

uint8_t* receive_response(int sock,uint8_t* src_put_to,size_t* len_put_to){
        uint8_t buff[8192];
	while(true){
        int l=recv(sock,buff,8192,0);
	if(l==-1){perror("l ret -1");close(sock);exit(0);}
	if(l>=(36+32+sizeof(hdr_t))){//radio+ieee+mydatahdr
		//check dest. is't for me ?
		if(memcmp(buff+36+16,my_mac,6)==0){//yes. it's for me! :) /* bss ? colunm */
			//check header
			hdr_t* hdr=(hdr_t*)(buff+36+32);
			if(memcmp(hdr->magic,"k4uwifi",7)==0 && hdr->magic_version==0x00){
				//check magic OK
				memcpy(src_put_to,buff+36+10,6);
				*len_put_to=(l-(36+32));
				printf("DEBUG: received cmd id %02x from %02x:%02x:%02x:%02x:%02x:%02x\n",hdr->command_id,*(buff+36+10),*(buff+36+11),*(buff+36+12),*(buff+36+13),\
					*(buff+36+14),*(buff+36+15));
				uint8_t * ret=malloc(*len_put_to);
				memcpy(ret,buff+36+32,*len_put_to);
				return ret;
			}
		}
	}
	}//while true
}

void fill_hdr(hdr_t* hdr,uint8_t cmd_id){
	memcpy(hdr->magic,"k4uwifi",7);
	hdr->magic_version=0x00;
	hdr->command_id=cmd_id;
}

void cmd_list(int sock){ //send get ownmac 
	printf("cmd list mode!\n");
	cmd_tell_you_mac_req_t tell_req;
	fill_hdr(&tell_req.hdr,PACKET_TYPE_TELL_YOUR_MAC_REQ);
	
	create_packet_and_send_data(sock,(uint8_t*)&tell_req,sizeof(tell_req));
	while(true){
		size_t len_put_to;
		uint8_t src_put_to[6];
		uint8_t* dat= receive_response(sock,(uint8_t*)src_put_to,&len_put_to);
		if(dat){
			if(len_put_to >= sizeof(cmd_tell_you_mac_response_t)){
				cmd_tell_you_mac_response_t *resp=(cmd_tell_you_mac_response_t*)dat;
				if(resp->hdr.command_id==PACKET_TYPE_TELL_YOUR_MAC_RESP){
					printf("received PACKET_TYPE_TELL_YOUR_MAC_RESP\n");
				}
			}
			free(dat);
		}
	}
}


void cmd_exec(int sock,const char* cmd){ 
	cmd_exec_cmd_t cmd_exec;
	cmd_push_t cmd_push;
	fill_hdr(&cmd_exec.hdr,PACKET_TYPE_EXEC_CMD);
        fill_hdr(&cmd_push.hdr,PACKET_TYPE_PUSHCMD);
	strcpy(&cmd_push.cmd[0],cmd);
	create_packet_and_send_data(sock,(uint8_t*)&cmd_push,sizeof(cmd_push));

	size_t len_put_to;
        uint8_t src_put_to[6];

	        uint8_t* dat= receive_response(sock,(uint8_t*)src_put_to,&len_put_to);
		printf("dat=%p\n",dat);
                if(dat){
			printf("len put to = %d szof=%d\n",len_put_to , sizeof(cmd_push_resp_t));
                        if(len_put_to >= sizeof(cmd_push_resp_t)){
			        cmd_push_resp_t *push_resp=(cmd_push_resp_t*)dat;
				printf("len put to OK! cmd id=%d uniq = %d \n",push_resp->hdr.command_id,PACKET_TYPE_PUSH_RESP_UNIQ);
                                if(push_resp->hdr.command_id==PACKET_TYPE_PUSH_RESP_UNIQ){
                                        printf("received PACKET_TYPE_PUSH_RESP_UNIQ\n");
					memcpy(&cmd_exec.cmd_uniq_ident[0],&push_resp->cmd_uniq_ident[0],sizeof(cmd_exec.cmd_uniq_ident));
					char sha256[32];
					memcpy(&cmd_exec.sha256,&sha256[0],sizeof(cmd_exec.sha256));
					create_packet_and_send_data(sock,(uint8_t*)&cmd_exec,sizeof(cmd_exec));
					uint8_t* dat2= receive_response(sock,(uint8_t*)src_put_to,&len_put_to);
					if(dat2){
		                        if(len_put_to >= sizeof(cmd_exec_cmd_response_t)){
						cmd_exec_cmd_response_t *exec_resp=(cmd_exec_cmd_response_t*)dat2;
						 if(exec_resp->hdr.command_id==PACKET_TYPE_EXEC_CMD_RESP){
							printf("received PACKET_TYPE_EXEC_RESP\n");
							printf("PACKET_TYPE_EXEC_RESP status=%d statutext=%s\n",exec_resp->result_status,exec_resp->result_status_text);
						}//exec
					}//len=exec_resp
					free(dat2);
	                                }//dat2
				   }//resp uniq
                        }//len=push_resp
                        free(dat);
                }//dat
}//func


bool convert_string_to_mac(const char* from,uint8_t* to){
	int values[6];
	int i;
	uint8_t* to_ptr=to;
	if( 6 == sscanf( from, "%x:%x:%x:%x:%x:%x",&values[0], &values[1], &values[2],&values[3], &values[4], &values[5] ) ){
		for( i = 0; i < 6; ++i ){
			*(to_ptr++) = (uint8_t) values[i];
		}
		printf("convert_string_to_mac(%s) = (%02x:%02x:%02x:%02x:%02x:%02x)\n",from,*(to+0),*(to+1),*(to+2),*(to+3),*(to+4),*(to+5));
		return true;
	}else{
		return false;
	}
}

int main(int argc,const char** argv){
    printf("hello from main.\n");
	int sock=openSocket("wlan0");
    perror("");
	printf("sock open result=%d\n",sock);
	if(argc==2 && strcmp(argv[1],"--list")==0){
		cmd_list(sock);
	}else if(argc==4 && strcmp(argv[1],"--gpio")==0 && strlen(argv[3])<5  ){
		if(convert_string_to_mac(argv[2],dest_mac)){
			char cc[32];
			sprintf(cc,"gpio_trigger %s 10",argv[3]);
			printf("requesting exec: %s\n",cc);
			cmd_exec(sock,cc);
		}else{
			printf("bad mac. use mac in lower case. \n");
		}
	}else{
		printf("use remote_esp8266_client --list/--gpio <mac:lower:case:xx:xx:xx> <gpio_id>\n");
	}
	close(sock);
}
